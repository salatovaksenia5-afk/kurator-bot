import os
import json
import asyncio
import gspread
from google.oauth2.service_account import Credentials
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta, time, timezone
from aiohttp import web
from aiogram import Bot, Dispatcher, F, Router, types
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ReplyKeyboardMarkup,
    KeyboardButton
)

# === –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ===
BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
if not BOT_TOKEN:
    raise RuntimeError("–ù–µ—Ç BOT_TOKEN. –ó–∞–¥–∞–π –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è BOT_TOKEN –Ω–∞ Render.")

ADMIN_ID = int(os.getenv("ADMIN_ID", "0") or "0")
ACCESS_CODE = os.getenv("ACCESS_CODE", "–ª–µ—Ç–ª2025").strip()
TIMEZONE = timezone(timedelta(hours=3))  # –ú–°–ö
REMIND_HOUR = 14  # –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–æ–≤–∏—á–∫–∞–º –≤ 14:00
DEADLINE_HOUR = 22  # –¥–µ–¥–ª–∞–π–Ω —Å–¥–∞—á–∏ –∑–∞–¥–∞–Ω–∏—è –≤ 22:00
PORT = int(os.getenv("PORT", "10000"))
DATA_DIR = "data"
USERS_FILE = os.path.join(DATA_DIR, "users.json")
GUIDES_FILE = os.path.join(DATA_DIR, "guides.json")
os.makedirs(DATA_DIR, exist_ok=True)

# === Google Sheets ===
SHEET_ID = os.getenv("SHEET_ID", "17zqwZ0MNNJWjzVfmBluLXyRGt-ogC14QxtXhTfEPsNU/edit?hl=ru&gid=0#gid=0").strip()
SHEET_TAB = os.getenv("SHEET_TAB", "–õ–∏—Å—Ç1").strip()
GOOGLE_CREDENTIALS = os.getenv("GOOGLE_CREDENTIALS", "").strip()
CHAT_LINK_NEWBIE = os.getenv("CHAT_LINK_NEWBIE", "").strip()

def _read_json(path, default=None):
    if not os.path.exists(path):
        return default
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)

def _write_json(path: str, payload):
    tmp = path + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)

def load_guides():
    data = _read_json(GUIDES_FILE, {})
    if not data:
        data = {
            "newbie": [
                {"id": "n1", "title": "–ì–∞–π–¥ 1: –û—Å–Ω–æ–≤—ã –∏ —ç—Ç–∏–∫–∞", "url": "https://example.com/g1"},
                {"id": "n2", "title": "–ì–∞–π–¥ 2: –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —á–∞—Å—Ç—å", "url": "https://example.com/g2"},
                {"id": "n3", "title": "–ì–∞–π–¥ 3: –ü—Ä–µ–¥–º–µ—Ç—ã", "url": "https://example.com/g3"},
            ],
            "letnik": [
                {"id": "l1", "title": "–ì–∞–π–¥1: –û—Å–Ω–æ–≤—ã –∏ —ç—Ç–∏–∫–∞", "url": "https://example.com/la"},
                {"id": "l2", "title": "–ì–∞–π–¥ 2: –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —á–∞—Å—Ç—å", "url": "https://example.com/lb"},
                {"id": "l3", "title": "–ì–∞–π–¥ 3: –ü—Ä–µ–¥–º–µ—Ç—ã", "url": "https://example.com/lc"},
            ],
            "subjects": [
                "–∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞", "—Ñ–∏–∑–∏–∫–∞", "—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫",
                "–æ–±—â–µ—Å—Ç–≤–æ–∑–Ω–∞–Ω–∏–µ", "–±–∏–æ–ª–æ–≥–∏—è", "—Ö–∏–º–∏—è",
                "–ø—Ä–æ—Ñ–∏–ª—å–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞"
            ],
            "tasks_third_by_subject": {
                "–∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∞": "–°–æ—Å—Ç–∞–≤—å –º–∏–Ω–∏-–∫–æ–Ω—Å–ø–µ–∫—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–µ—à–µ–Ω–∏—è —Ç–∏–ø–æ–≤–æ–π –∑–∞–¥–∞—á–∏ –ï–ì–≠ –∏ –∑–∞–ø–∏—à–∏ 3 –ø—Ä–∏–º–µ—Ä–∞.",
                "—Ñ–∏–∑–∏–∫–∞": "–†–∞–∑–±–µ—Ä–∏ –∑–∞–¥–∞—á—É –Ω–∞ –∑–∞–∫–æ–Ω—ã –ù—å—é—Ç–æ–Ω–∞: —É—Å–ª–æ–≤–∏—è, —Ñ–æ—Ä–º—É–ª—ã, —Ä–µ—à–µ–Ω–∏–µ –∏ –æ—Ç–≤–µ—Ç.",
                "—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫": "–ù–∞–ø–∏—à–∏ –ø–ª–∞–Ω —Å–æ—á–∏–Ω–µ–Ω–∏—è –ø–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–æ–π —Ç–µ–º–µ + 3 –∞—Ä–≥—É–º–µ–Ω—Ç–∞.",
                "–æ–±—â–µ—Å—Ç–≤–æ–∑–Ω–∞–Ω–∏–µ": "–î–∞–π –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è 5-—Ç–∏ –∫–ª—é—á–µ–≤—ã—Ö —Ç–µ—Ä–º–∏–Ω–æ–≤ –∏–∑ —Ç–µ–º—ã –∏ –ø—Ä–∏–≤–µ–¥–∏ –ø—Ä–∏–º–µ—Ä—ã.",
                "–±–∏–æ–ª–æ–≥–∏—è": "–ù–∞–±—Ä–æ—Å–∞–π —Å—Ö–µ–º—É –ø—Ä–æ—Ü–µ—Å—Å–∞ (—Ñ–æ—Ç–æ—Å–∏–Ω—Ç–µ–∑/–∫–ª–µ—Ç–æ—á–Ω–æ–µ –¥—ã—Ö–∞–Ω–∏–µ) –∏ –ø–æ—è—Å–Ω–∏ —ç—Ç–∞–ø—ã.",
                "—Ö–∏–º–∏—è": "–°–æ—Å—Ç–∞–≤—å 3 —É—Ä–∞–≤–Ω–µ–Ω–∏—è —Ä–µ–∞–∫—Ü–∏–π –ø–æ —Ç–µ–º–µ –∏ –ø—Ä–æ–≥–æ–≤–æ—Ä–∏ –ø—Ä–∞–≤–∏–ª–∞ —É—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è.",
                "–ø—Ä–æ—Ñ–∏–ª—å–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞": "–†–µ—à–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä"
            }
        }
        _write_json(GUIDES_FILE, data)
    return data

GUIDES = load_guides()

@dataclass
class Progress:
    role: str = "newbie"
    name: str = None
    subject: str = None
    allow_letnik: bool = False
    guide_index: int = 0
    last_guide_sent_at: str = None
    has_read_today: bool = False
    task_done_dates: list = None
    created_at: str = None

    def to_dict(self):
        d = asdict(self)
        if d["task_done_dates"] is None:
            d["task_done_dates"] = []
        return d

def now_msk() -> datetime:
    return datetime.now(TIMEZONE)

def today_msk() -> datetime.date:
    return now_msk().date()

def iso(dt: datetime) -> str:
    return dt.astimezone(TIMEZONE).isoformat()

def is_time_before_deadline(dt: datetime) -> bool:
    return dt.time() < time(DEADLINE_HOUR, 0)

def load_users() -> dict[str, dict]:
    data = _read_json(USERS_FILE, {})
    changed = False
    for uid, raw in list(data.items()):
        if "task_done_dates" not in raw:
            raw["task_done_dates"] = []
            changed = True
        if "has_read_today" not in raw:
            raw["has_read_today"] = False
            changed = True
        if "allow_letnik" not in raw:
            raw["allow_letnik"] = False
            changed = True
        if "created_at" not in raw:
            raw["created_at"] = iso(now_msk())
            changed = True
    if changed:
        _write_json(USERS_FILE, data)
    return data

def save_users(data: dict):
    _write_json(USERS_FILE, data)

USERS: dict[str, dict] = load_users()

def get_user(uid: int) -> Progress:
    key = str(uid)
    if key not in USERS:
        USERS[key] = Progress(created_at=iso(now_msk())).to_dict()
        save_users(USERS)
    p = Progress(**USERS[key])
    if p.task_done_dates is None:
        p.task_done_dates = []
    return p

def put_user(uid: int, p: Progress):
    USERS[str(uid)] = p.to_dict()
    save_users(USERS)

def kb_role() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="–Ø –Ω–æ–≤–∏—á–æ–∫"), KeyboardButton(text="–Ø –ª–µ—Ç–Ω–∏–∫")]
        ],
        resize_keyboard=True
    )

def kb_main_newbie(p: Progress) -> InlineKeyboardMarkup:
    rows = []
    rows.append([InlineKeyboardButton(text="üìò –í—ã–±—Ä–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç", callback_data="subject:menu")])
    if p.subject:
        rows.append([InlineKeyboardButton(text="üìñ –û—Ç–∫—Ä—ã—Ç—å –≥–∞–π–¥", callback_data="newbie:open_guide")])
        rows.append([InlineKeyboardButton(text="‚úÖ –Ø –≤—ã–ø–æ–ª–Ω–∏–ª –∑–∞–¥–∞–Ω–∏–µ", callback_data="newbie:task_done")])
    rows.append([InlineKeyboardButton(text="üìä –ü—Ä–æ–≥—Ä–µ—Å—Å", callback_data="progress:me")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

def kb_main_letnik(p: Progress) -> InlineKeyboardMarkup:
    rows = []
    rows.append([InlineKeyboardButton(text="üìò –í—ã–±—Ä–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç", callback_data="subject:menu")])
    if p.allow_letnik:
        rows.append([InlineKeyboardButton(text="‚ö° –í—Å–µ –≥–∞–π–¥—ã –ª–µ—Ç–Ω–∏–∫–∞", callback_data="letnik:all")])
    else:
        rows.append([InlineKeyboardButton(text="üîí –í–≤–µ—Å—Ç–∏ –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞", callback_data="letnik:code")])
    rows.append([InlineKeyboardButton(text="üìä –ü—Ä–æ–≥—Ä–µ—Å—Å", callback_data="progress:me")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

def kb_subjects() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text=s.title(), callback_data=f"subject:set:{s}")]
            for s in GUIDES["subjects"]
        ]
    )

def kb_read_confirm() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üìñ –Ø –ø—Ä–æ—á–∏—Ç–∞–ª(–∞) –≥–∞–π–¥", callback_data="newbie:read_confirm")]
        ]
    )

class RegStates(StatesGroup):
    waiting_role = State()
    waiting_name = State()
    waiting_subject = State()
    waiting_letnik_code = State()

bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
router = Router()
dp.include_router(router)

@dp.message(F.text)
async def capture_full_name(message: Message):
    u = get_user(message.from_user.id)
    if not u or not getattr(u, "awaiting_full_name", False):
        return
    full = message.text.strip()
    if len(full.split()) < 2:
        await message.answer("–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ñ–∞–º–∏–ª–∏—é –∏ –∏–º—è. –ü—Ä–∏–º–µ—Ä: <i>–ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω</i>")
        return
    u.full_name = full
    u.awaiting_full_name = False
    put_user(message.from_user.id, u)

    try:
        gs_set(message.from_user.id, {"–§–ò": full})
    except Exception:
        pass

    await message.answer("–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –ø—Ä–µ–¥–º–µ—Ç:", reply_markup=kb_subjects())

@dp.callback_query(F.data.startswith("subject:set:"))
async def subject_set(cb: CallbackQuery):
    s = cb.data.split(":")[2]
    u = get_user(cb.from_user.id)
    u.subject = s
    put_user(cb.from_user.id, u)

    try:
        gs_set(cb.from_user.id, {"–ü—Ä–µ–¥–º–µ—Ç": s})
    except Exception:
        pass

    await cb.message.answer(f"üìò –ü—Ä–µ–¥–º–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω: <b>{s}</b>")

    if u.role == "newbie" and CHAT_LINK_NEWBIE and not getattr(u, "hr_chat_link_sent", False):
        u.hr_chat_link_sent = True
        put_user(cb.from_user.id, u)
        try:
            gs_set(cb.from_user.id, {"–í —á–∞—Ç–µ –Ω–æ–≤–∏—á–∫–æ–≤": "—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞"})
        except Exception:
            pass
        await cb.message.answer(
            f"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—Å—Ç—É–ø–∏ –≤ —á–∞—Ç –Ω–æ–≤–∏—á–∫–æ–≤ –ø–æ —Å—Å—ã–ª–∫–µ:\n{CHAT_LINK_NEWBIE}\n\n"
            f"–ü–æ—Å–ª–µ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è —Ç–µ–±–µ –Ω–∞—á–Ω—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≥–∞–π–¥—ã (–ø–æ—Å–ª–µ 08:00 –ú–°–ö)."
        )

    await cb.answer()

@dp.callback_query(F.data == "task:done")
async def task_done(cb: CallbackQuery):
    u = get_user(cb.from_user.id)
    role = u.role
    items = GUIDES["newbie"] if role == "newbie" else GUIDES["letnik"]

    idx = u.guide_index
    guide = None
    if role == "newbie":
        if idx < len(items):
            guide = items[idx]
    else:
        guide = items[0] if items else None

    if not guide:
        await cb.message.answer("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ –æ—Ç–º–µ—á–∞—Ç—å.")
        await cb.answer()
        return

    prog = u.__dict__.setdefault("progress", {})
    gstat = prog.setdefault(guide["id"], {"read": True, "task_done": False})
    gstat["read"] = True
    gstat["task_done"] = True
    put_user(cb.from_user.id, u)

    await cb.message.answer(f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ –ø–æ ¬´{guide['title']}¬ª –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–µ!")

    if role == "newbie":
        guide_num = u.guide_index + 1
        try:
            gs_set(cb.from_user.id, {f"–ó–∞–¥–∞–Ω–∏–µ {guide_num}": "–≤—ã–ø–æ–ª–Ω–µ–Ω–æ"})
        except Exception:
            pass
    else:
        try:
            gs_set(cb.from_user.id, {"–°—Ç–∞—Ç—É—Å": "–¢–µ—Å—Ç —É –ª–µ—Ç–Ω–∏–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è"})
        except Exception:
            pass

    await cb.answer()

@dp.callback_query(F.data == "final_test")
async def process_final_test(cb: CallbackQuery):
    u = get_user(cb.from_user.id)
    uid = cb.from_user.id
    role = u.role

    if role != "newbie":
        await cb.answer("–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç ‚Äî –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤.", show_alert=True)
        return

    u.final_test_done = True
    u.finished_at = datetime.now(TIMEZONE).isoformat()
    put_user(uid, u)

    try:
        gs_set(uid, {
            "–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç": "‚úì",
            "–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è": datetime.now(TIMEZONE).strftime("%Y-%m-%d"),
            "–°—Ç–∞—Ç—É—Å": "–ó–∞–≤–µ—Ä—à–∏–ª –æ–±—É—á–µ–Ω–∏–µ"
        })
    except Exception:
        pass

    await cb.message.answer(
        "üéì <b>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!</b>\n"
        "–¢—ã –ø—Ä–æ—à—ë–ª –æ–±—É—á–µ–Ω–∏–µ –∫—É—Ä–∞—Ç–æ—Ä–∞. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–æ–º–∞–Ω–¥—É! ü•≥\n\n"
        "–°–≤—è–∂–∏—Å—å —Å–æ —Å—Ç–∞—Ä—à–∏–º –∫—É—Ä–∞—Ç–æ—Ä–æ–º –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–æ–≤."
    )
    await cb.answer()

@router.callback_query(lambda c: c.data.startswith("test_"))
async def process_test(callback_query: types.CallbackQuery):
    subject = callback_query.data.split("_", 1)[1]
    
    await callback_query.message.answer(
        f"üìò –¢–µ—Å—Ç –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É {subject}.\n"
        f"–°–∫–æ—Ä–æ –∑–¥–µ—Å—å –±—É–¥—É—Ç –≤–æ–ø—Ä–æ—Å—ã!"
    )
    await bot.answer_callback_query(callback_query.id)

@router.callback_query(lambda c: c.data == "final_test")
async def process_final_test(callback_query: types.CallbackQuery):
    await callback_query.message.answer(
        "üéì –§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç!\n"
        "–ó–¥–µ—Å—å –±—É–¥—É—Ç –∑–∞–∫–ª—é—á–∏—Ç–µ–ª—å–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–Ω–∞–Ω–∏–π."
    )
    await bot.answer_callback_query(callback_query.id)

async def send_newbie_today_guide(uid: int, p: Progress):
    items = GUIDES["newbie"]
    idx = p.guide_index
    if idx >= len(items):
        await bot.send_message(uid, "üéâ –¢—ã –ø—Ä–æ—à—ë–ª(–ª–∞) –≤—Å–µ –Ω–æ–≤–∏—á–∫–æ–≤—ã–µ –≥–∞–π–¥—ã!")
        return

    g = items[idx]
    p.last_guide_sent_at = iso(now_msk())
    p.has_read_today = False
    put_user(uid, p)

    text = (
        f"üìò –°–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –≥–∞–π–¥:\n<b>{g['title']}</b>\n{g['url']}\n\n"
        f"–ü–æ—Å–ª–µ –ø—Ä–æ—á—Ç–µ–Ω–∏—è –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ. –ó–∞–¥–∞–Ω–∏–µ –æ—Ç–∫—Ä–æ–µ—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.\n"
        f"–î–µ–¥–ª–∞–π–Ω —Å–¥–∞—á–∏ ‚Äî <b>{DEADLINE_HOUR}:00</b> –ø–æ –ú–°–ö."
    )
    await bot.send_message(uid, text, reply_markup=kb_read_confirm())

def _today_iso_date() -> str:
    return today_msk().isoformat()

def _third_guide_task_for_subject(subject: str) -> str:
    tasks = GUIDES.get("tasks_third_by_subject", {})
    return tasks.get(subject or "", "–ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è 3-–≥–æ –≥–∞–π–¥–∞ –ø–æ —Ç–≤–æ–µ–º—É –ø—Ä–µ–¥–º–µ—Ç—É.")

async def send_newbie_task(uid: int, p: Progress):
    idx = p.guide_index
    items = GUIDES["newbie"]
    if idx >= len(items):
        await bot.send_message(uid, "üéâ –ù–æ–≤–∏—á–∫–æ–≤—ã–µ –≥–∞–π–¥—ã —É–∂–µ –≤—Å–µ –ø—Ä–æ–π–¥–µ–Ω—ã.")
        return

    g = items[idx]
    if g["id"] == "n3":
        task_text = _third_guide_task_for_subject(p.subject or "")
    else:
        task_text = "–ö—Ä–∞—Ç–∫–æ –∑–∞–∫–æ–Ω—Å–ø–µ–∫—Ç–∏—Ä—É–π –æ—Å–Ω–æ–≤–Ω—ã–µ –º—ã—Å–ª–∏ –≥–∞–π–¥–∞ –∏ –≤—ã–ø–æ–ª–Ω–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ."

    now = now_msk()
    if not is_time_before_deadline(now):
        deadline_note = "‚ö†Ô∏è –î–µ–¥–ª–∞–π–Ω —É–∂–µ –ø—Ä–æ—à—ë–ª. –ö–Ω–æ–ø–∫–∞ —Å–¥–∞—á–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."
    else:
        deadline_note = f"–°–¥–∞—Ç—å –º–æ–∂–Ω–æ –¥–æ <b>{DEADLINE_HOUR}:00</b> –ú–°–ö."

    await bot.send_message(
        uid,
        f"üìù –ó–∞–¥–∞–Ω–∏–µ –∫ ¬´{g['title']}¬ª:\n\n{task_text}\n\n{deadline_note}"
    )

def can_submit_now() -> bool:
    return is_time_before_deadline(now_msk())

@router.message(CommandStart())
async def cmd_start(m: Message, state: FSMContext):
    p = get_user(m.from_user.id)
    await state.clear()
    await state.set_state(RegStates.waiting_role)
    await m.answer(
        "–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç-–∫—É—Ä–∞—Ç–æ—Ä.\n\n–í—ã–±–µ—Ä–∏ —Å–≤–æ—é —Ä–æ–ª—å:",
        reply_markup=kb_role()
    )

@router.message(RegStates.waiting_role, F.text.lower().in_({"—è –Ω–æ–≤–∏—á–æ–∫", "—è –ª–µ—Ç–Ω–∏–∫"}))
async def choose_role(m: Message, state: FSMContext):
    p = get_user(m.from_user.id)
    is_newbie = (m.text.lower() == "—è –Ω–æ–≤–∏—á–æ–∫")
    p.role = "newbie" if is_newbie else "letnik"
    put_user(m.from_user.id, p)

    await state.set_state(RegStates.waiting_name)
    await m.answer("–û—Ç–ø—Ä–∞–≤—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <b>—Ñ–∞–º–∏–ª–∏—é –∏ –∏–º—è</b> –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä: –ò–≤–∞–Ω–æ–≤–∞ –ê–Ω–Ω–∞).",
                   reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(RegStates.waiting_name, F.text.len() >= 3)
async def take_name(m: Message, state: FSMContext):
    text = " ".join(m.text.strip().split())
    p = get_user(m.from_user.id)
    p.name = text
    put_user(m.from_user.id, p)

    await state.set_state(RegStates.waiting_subject)
    await m.answer(
        "–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –ø—Ä–µ–¥–º–µ—Ç:",
        reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–í—ã–±—Ä–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç")]], resize_keyboard=True)
    )
    await m.answer("üëá –ù–∞–∂–º–∏, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç:", reply_markup=None)
    await m.answer("–í—ã–±–æ—Ä –ø—Ä–µ–¥–º–µ—Ç–∞:", reply_markup=kb_subjects())

@router.callback_query(F.data.startswith("subject:set:"))
async def subject_set(cb: CallbackQuery, state: FSMContext):
    s = cb.data.split(":", 2)[2]
    p = get_user(cb.from_user.id)
    p.subject = s
    put_user(cb.from_user.id, p)

    await cb.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    if p.role == "newbie":
        await cb.message.answer(
            f"üìò –ü—Ä–µ–¥–º–µ—Ç: <b>{s.title()}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω.\n"
            f"–ö–Ω–æ–ø–∫–∏ –¥–ª—è —á—Ç–µ–Ω–∏—è –≥–∞–π–¥–∞ –∏ —Å–¥–∞—á–∏ –∑–∞–¥–∞–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã.",
            reply_markup=kb_main_newbie(p)
        )
        
        if CHAT_LINK_NEWBIE and not p.hr_chat_link_sent:
            p.hr_chat_link_sent = True
            put_user(cb.from_user.id, p)
            try:
                gs_set(cb.from_user.id, {"–í —á–∞—Ç–µ –Ω–æ–≤–∏—á–∫–æ–≤": "—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞"})
            except Exception:
                pass
            await cb.message.answer(
                f"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—Å—Ç—É–ø–∏ –≤ —á–∞—Ç –Ω–æ–≤–∏—á–∫–æ–≤ –ø–æ —Å—Å—ã–ª–∫–µ:\n{CHAT_LINK_NEWBIE}\n\n"
                f"–ü–æ—Å–ª–µ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è —Ç–µ–±–µ –Ω–∞—á–Ω—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≥–∞–π–¥—ã (–ø–æ—Å–ª–µ 08:00 –ú–°–ö)."
            )

        await cb.message.answer(
            "–ì–∞–π–¥—ã –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤ –ø—Ä–∏—Ö–æ–¥—è—Ç –∫–∞–∂–¥—ã–π –¥–µ–Ω—å <b>–ø–æ—Å–ª–µ 08:00</b> –ø–æ –ú–°–ö.\n"
            "–ï—Å–ª–∏ –±–æ—Ç –±—ã–ª –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω –ø–æ–∑–∂–µ ‚Äî –≥–∞–π–¥ –ø—Ä–∏–¥—ë—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞."
        )
    else:
        await cb.message.answer(
            f"üìò –ü—Ä–µ–¥–º–µ—Ç: <b>{s.title()}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω.",
            reply_markup=kb_main_letnik(p)
        )

@router.callback_query(F.data == "subject:menu")
async def subject_menu(cb: CallbackQuery):
    await cb.message.answer("–í—ã–±–æ—Ä –ø—Ä–µ–¥–º–µ—Ç–∞:", reply_markup=kb_subjects())
    await cb.answer()

@router.callback_query(F.data == "letnik:code")
async def ask_letnik_code(cb: CallbackQuery, state: FSMContext):
    p = get_user(cb.from_user.id)
    if p.allow_letnik:
        await cb.answer("–î–æ—Å—Ç—É–ø —É–∂–µ –æ—Ç–∫—Ä—ã—Ç")
        return
    await state.set_state(RegStates.waiting_letnik_code)
    await cb.message.answer("–í–≤–µ–¥–∏ –∫–æ–¥ –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ª–µ—Ç–Ω–∏–∫–æ–≤:")
    await cb.answer()

@router.message(RegStates.waiting_letnik_code)
async def check_letnik_code(m: Message, state: FSMContext):
    p = get_user(m.from_user.id)
    code = (m.text or "").strip()
    if code == ACCESS_CODE:
        p.allow_letnik = True
        put_user(m.from_user.id, p)
        await state.clear()
        await m.answer("‚úÖ –ö–æ–¥ –≤–µ—Ä–Ω—ã–π. –î–æ—Å—Ç—É–ø –∫ –≥–∞–π–¥–∞–º –ª–µ—Ç–Ω–∏–∫–∞ –æ—Ç–∫—Ä—ã—Ç.", reply_markup=None)
        await m.answer("–ú–µ–Ω—é:", reply_markup=kb_main_letnik(p))
    else:
        await m.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ –∏–ª–∏ –Ω–∞–∂–º–∏ /start –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞.")

@router.callback_query(F.data == "letnik:all")
async def letnik_all(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    if not p.allow_letnik:
        await cb.answer("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞. –í–≤–µ–¥–∏ –∫–æ–¥.", show_alert=True)
        return
    items = GUIDES["letnik"]
    text = "‚ö° –í—Å–µ –≥–∞–π–¥—ã –¥–ª—è –ª–µ—Ç–Ω–∏–∫–æ–≤:\n\n" + "\n".join([f"‚Ä¢ <b>{g['title']}</b> ‚Äî {g['url']}" for g in items])
    await cb.message.answer(text)
    await cb.answer()

@router.callback_query(F.data == "newbie:open_guide")
async def newbie_open_guide(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    if p.role != "newbie":
        await cb.answer("–î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –Ω–æ–≤–∏—á–∫–∞–º.", show_alert=True)
        return
    if not p.subject:
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –ø—Ä–µ–¥–º–µ—Ç.", show_alert=True)
        return

    items = GUIDES["newbie"]
    idx = p.guide_index
    if idx >= len(items):
        await cb.message.answer("üéâ –¢—ã —É–∂–µ –ø—Ä–æ—à—ë–ª(–ª–∞) –≤—Å–µ –Ω–æ–≤–∏—á–∫–æ–≤—ã–µ –≥–∞–π–¥—ã!")
        await cb.answer()
        return

    g = items[idx]
    await cb.message.answer(
        f"üìò –¢–µ–∫—É—â–∏–π –≥–∞–π–¥:\n<b>{g['title']}</b>\n{g['url']}\n\n"
        f"–ü–æ—Å–ª–µ –ø—Ä–æ—á—Ç–µ–Ω–∏—è –Ω–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–¥–∞–Ω–∏–µ.",
        reply_markup=kb_read_confirm()
    )
    await cb.answer()

@router.callback_query(F.data == "newbie:read_confirm")
async def newbie_mark_read(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    if p.role != "newbie":
        await cb.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤")
        return
    p.has_read_today = True
    put_user(cb.from_user.id, p)
    await cb.message.answer("–û—Ç–ª–∏—á–Ω–æ! –ì–∞–π–¥ –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–π. –í–æ—Ç –∑–∞–¥–∞–Ω–∏–µ:")
    await send_newbie_task(cb.from_user.id, p)
    await cb.answer()

@router.callback_query(F.data == "newbie:task_done")
async def newbie_task_done(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    if p.role != "newbie":
        await cb.answer("–¢–æ–ª—å–∫–æ –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤")
        return
    if not p.subject:
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –ø—Ä–µ–¥–º–µ—Ç.", show_alert=True)
        return

    if not can_submit_now():
        await cb.answer("–ü–æ—Å–ª–µ 22:00 —Å–¥–∞—á–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ üòî", show_alert=True)
        return

    if not p.has_read_today:
        await cb.answer("–°–Ω–∞—á–∞–ª–∞ –æ—Ç–º–µ—Ç—å, —á—Ç–æ –ø—Ä–æ—á–∏—Ç–∞–ª(–∞) –≥–∞–π–¥.", show_alert=True)
        return

    tiso = _today_iso_date()
    if tiso not in p.task_done_dates:
        p.task_done_dates.append(tiso)

    p.guide_index += 1
    p.has_read_today = False
    put_user(cb.from_user.id, p)

    await cb.message.answer("‚úÖ –ó–∞–¥–∞–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ! –ù–æ–≤—ã–π –≥–∞–π–¥ –ø—Ä–∏–¥—ë—Ç –ø–æ—Å–ª–µ 08:00 –ø–æ –ú–°–ö.")
    await cb.answer()

@router.callback_query(F.data == "progress:me")
async def progress_me(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    role = p.role
    subject = p.subject or "–Ω–µ –≤—ã–±—Ä–∞–Ω"
    if role == "newbie":
        total = len(GUIDES["newbie"])
        done = min(p.guide_index, total)
        text = (
            "üìä –¢–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å:\n\n"
            f"–†–æ–ª—å: –Ω–æ–≤–∏—á–æ–∫\n"
            f"–ü—Ä–µ–¥–º–µ—Ç: <b>{subject}</b>\n"
            f"–ü—Ä–æ–π–¥–µ–Ω–æ –≥–∞–π–¥–æ–≤: <b>{done}</b> –∏–∑ <b>{total}</b>\n"
            f"–°–¥–∞–Ω–æ –¥–Ω–µ–π: <b>{len(p.task_done_dates)}</b>\n"
        )
    else:
        text = (
            "üìä –¢–≤–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å:\n\n"
            f"–†–æ–ª—å: –ª–µ—Ç–Ω–∏–∫\n"
            f"–ü—Ä–µ–¥–º–µ—Ç: <b>{subject}</b>\n"
            f"–î–æ—Å—Ç—É–ø –∫ –≥–∞–π–¥–∞–º –ª–µ—Ç–Ω–∏–∫–∞: {'–¥–∞' if p.allow_letnik else '–Ω–µ—Ç'}\n"
        )
    await cb.message.answer(text)
    await cb.answer()

@router.message(Command("admin"))
async def admin_stats(m: Message):
    if ADMIN_ID and m.from_user.id != ADMIN_ID:
        return
    total = len(USERS)
    newbies = sum(1 for u in USERS.values() if u.get("role") == "newbie")
    letniki = sum(1 for u in USERS.values() if u.get("role") == "letnik")
    lines = [
        f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}",
        f"üü¢ –ù–æ–≤–∏—á–∫–æ–≤: {newbies}",
        f"üü† –õ–µ—Ç–Ω–∏–∫–æ–≤: {letniki}",
        "",
        "–ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π:"
    ]
    last = sorted(USERS.items(), key=lambda kv: kv[1].get("created_at", ""), reverse=True)[:10]
    for uid, u in last:
        lines.append(f"{uid}: {u.get('name') or '‚Äî'} | {u.get('role')} | subj:{u.get('subject') or '‚Äî'} | idx:{u.get('guide_index', 0)}")
    await m.answer("\n".join(lines))

async def scheduler_loop():
    await asyncio.sleep(2)
    now = now_msk()
    if now.time() >= time(8, 0):
        for uid, raw in list(USERS.items()):
            p = Progress(**raw)
            if p.role != "newbie":
                continue
            last_date = None
            if p.last_guide_sent_at:
                try:
                    last_date = datetime.fromisoformat(p.last_guide_sent_at).astimezone(TIMEZONE).date()
                except Exception:
                    last_date = None
            if last_date != today_msk():
                try:
                    await send_newbie_today_guide(int(uid), p)
                    await asyncio.sleep(0.1)
                except Exception:
                    pass

    while True:
        try:
            now = now_msk()

            if now.time().hour == 8 and now.time().minute == 0:
                for uid, raw in list(USERS.items()):
                    p = Progress(**raw)
                    if p.role != "newbie":
                        continue
                    last_date = None
                    if p.last_guide_sent_at:
                        try:
                            last_date = datetime.fromisoformat(p.last_guide_sent_at).astimezone(TIMEZONE).date()
                        except Exception:
                            last_date = None
                    if last_date == today_msk():
                        continue
                    await send_newbie_today_guide(int(uid), p)
                    await asyncio.sleep(0.1)

            if now.time().hour == REMIND_HOUR and now.time().minute == 0:
                for uid, raw in list(USERS.items()):
                    p = Progress(**raw)
                    if p.role != "newbie":
                        continue
                    await bot.send_message(int(uid), f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: —Å–¥–∞—Ç—å —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –¥–æ <b>{DEADLINE_HOUR}:00</b> –ø–æ –ú–°–ö.")
                    await asyncio.sleep(0.05)

            await asyncio.sleep(60)
        except asyncio.CancelledError:
            break
        except Exception:
            await asyncio.sleep(5)

async def handle_root(request):
    return web.Response(text="kurator-bot ok")

async def handle_health(request):
    return web.json_response({"status": "ok", "ts": iso(now_msk())})

async def start_web_app():
    app = web.Application()
    app.add_routes([web.get("/", handle_root), web.get("/health", handle_health)])
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()

async def main():
    await start_web_app()
    asyncio.create_task(scheduler_loop())
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
# ... [–ü—Ä–µ–¥—ã–¥—É—â–∏–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ subject_set] ...

@router.callback_query(F.data.startswith("subject:set:"))
async def subject_set(cb: CallbackQuery, state: FSMContext):
    s = cb.data.split(":", 2)[2]
    p = get_user(cb.from_user.id)
    p.subject = s
    put_user(cb.from_user.id, p)

    try:
        gs_set(cb.from_user.id, {"–ü—Ä–µ–¥–º–µ—Ç": s})
    except Exception:
        pass

    await cb.answer("–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ")
    if p.role == "newbie":
        await cb.message.answer(
            f"üìò –ü—Ä–µ–¥–º–µ—Ç: <b>{s.title()}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω.\n"
            f"–ö–Ω–æ–ø–∫–∏ –¥–ª—è —á—Ç–µ–Ω–∏—è –≥–∞–π–¥–∞ –∏ —Å–¥–∞—á–∏ –∑–∞–¥–∞–Ω–∏—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã.",
            reply_markup=kb_main_newbie(p)
        )
        
        if CHAT_LINK_NEWBIE and not p.hr_chat_link_sent:
            p.hr_chat_link_sent = True
            put_user(cb.from_user.id, p)
            try:
                gs_set(cb.from_user.id, {"–í —á–∞—Ç–µ –Ω–æ–≤–∏—á–∫–æ–≤": "—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞"})
            except Exception:
                pass
            
            await cb.message.answer(
                f"üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—Å—Ç—É–ø–∏ –≤ —á–∞—Ç –Ω–æ–≤–∏—á–∫–æ–≤ –ø–æ —Å—Å—ã–ª–∫–µ:\n{CHAT_LINK_NEWBIE}\n\n"
                f"–ü–æ—Å–ª–µ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è —Ç–µ–±–µ –Ω–∞—á–Ω—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≥–∞–π–¥—ã (–ø–æ—Å–ª–µ 08:00 –ú–°–ö)."
            )
        
        await cb.message.answer(
            "–ì–∞–π–¥—ã –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤ –ø—Ä–∏—Ö–æ–¥—è—Ç –∫–∞–∂–¥—ã–π –¥–µ–Ω—å <b>–ø–æ—Å–ª–µ 08:00</b> –ø–æ –ú–°–ö.\n"
            "–ï—Å–ª–∏ –±–æ—Ç –±—ã–ª –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω –ø–æ–∑–∂–µ ‚Äî –≥–∞–π–¥ –ø—Ä–∏–¥—ë—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞."
        )
    else:
        await cb.message.answer(
            f"üìò –ü—Ä–µ–¥–º–µ—Ç: <b>{s.title()}</b> —Å–æ—Ö—Ä–∞–Ω—ë–Ω.",
            reply_markup=kb_main_letnik(p)
        )

# [–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏–∑ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞]
async def send_newbie_next_guide(uid: int):
    u = get_user(uid)
    if not u or u.role != "newbie":
        return
    idx = u.guide_index
    items = GUIDES["newbie"]
    if idx >= len(items):
        await bot.send_message(uid, "üéâ –í—Å–µ –≥–∞–π–¥—ã –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤ –ø—Ä–æ–π–¥–µ–Ω—ã! –ú–æ–∂–Ω–æ –ø–æ–ø—Ä–æ—Å–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ª–µ—Ç–Ω–∏–∫ —É —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è.")
        return
    
    g = items[idx]
    u.last_guide_sent_at = iso(now_msk())
    put_user(uid, u)

    await bot.send_message(
        uid,
        f"üìò –°–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –≥–∞–π–¥: <b>{g['title']}</b>\n–°—Å—ã–ª–∫–∞: {g['url']}\n\n"
        f"–ù–µ –∑–∞–±—É–¥—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ –∫ 22:00 –ø–æ –ú–°–ö."
    )

    try:
        gs_set(uid, {f"–ì–∞–π–¥ {idx + 1}": "–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω"})
    except Exception:
        pass

@router.callback_query(F.data == "task:done")
async def task_done(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    role = p.role
    items = GUIDES["newbie"] if role == "newbie" else GUIDES["letnik"]

    idx = p.guide_index
    guide = None
    if role == "newbie":
        if idx < len(items):
            guide = items[idx]
    else:
        guide = items[0] if items else None

    if not guide:
        await cb.message.answer("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ –æ—Ç–º–µ—á–∞—Ç—å.")
        await cb.answer()
        return

    if not hasattr(p, 'progress'):
        p.progress = {}
    p.progress[guide["id"]] = {"read": True, "task_done": True}
    put_user(cb.from_user.id, p)

    await cb.message.answer(f"‚úÖ –ó–∞–¥–∞–Ω–∏–µ –ø–æ ¬´{guide['title']}¬ª –æ—Ç–º–µ—á–µ–Ω–æ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–æ–µ!")

    try:
        if role == "newbie":
            gs_set(cb.from_user.id, {f"–ó–∞–¥–∞–Ω–∏–µ {idx + 1}": "–≤—ã–ø–æ–ª–Ω–µ–Ω–æ"})
        else:
            gs_set(cb.from_user.id, {"–°—Ç–∞—Ç—É—Å": "–¢–µ—Å—Ç —É –ª–µ—Ç–Ω–∏–∫–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è"})
    except Exception:
        pass

    await cb.answer()

@router.callback_query(F.data == "final_test")
async def process_final_test(cb: CallbackQuery):
    p = get_user(cb.from_user.id)
    if p.role != "newbie":
        await cb.answer("–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç ‚Äî –¥–ª—è –Ω–æ–≤–∏—á–∫–æ–≤.", show_alert=True)
        return

    p.final_test_done = True
    p.finished_at = iso(now_msk())
    put_user(cb.from_user.id, p)

    try:
        gs_set(cb.from_user.id, {
            "–§–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç": "‚úì",
            "–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è": today_msk().isoformat(),
            "–°—Ç–∞—Ç—É—Å": "–ó–∞–≤–µ—Ä—à–∏–ª –æ–±—É—á–µ–Ω–∏–µ"
        })
    except Exception:
        pass

    await cb.message.answer(
        "üéì <b>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!</b>\n"
        "–¢—ã –ø—Ä–æ—à—ë–ª –æ–±—É—á–µ–Ω–∏–µ –∫—É—Ä–∞—Ç–æ—Ä–∞. –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–æ–º–∞–Ω–¥—É! ü•≥\n\n"
        "–°–≤—è–∂–∏—Å—å —Å–æ —Å—Ç–∞—Ä—à–∏–º –∫—É—Ä–∞—Ç–æ—Ä–æ–º –¥–ª—è —Å–ª–µ–¥—É—é—â–∏—Ö —à–∞–≥–æ–≤."
    )
    await cb.answer()

# [–û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π]
async def handle_root(request):
    return web.Response(text="kurator-bot ok")

async def handle_health(request):
    return web.json_response({"status": "ok", "ts": iso(now_msk())})

async def start_web_app():
    app = web.Application()
    app.add_routes([web.get("/", handle_root), web.get("/health", handle_health)])
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", PORT)
    await site.start()

async def main():
    await start_web_app()
    asyncio.create_task(scheduler_loop())
    await dp.start_polling(bot)
if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
from aiohttp import web
import asyncio

async def health(request):
    return web.Response(text="OK")

async def start_web_app():
    app = web.Application()
    app.router.add_get("/health", health)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, "0.0.0.0", 8080)
    await site.start()

# –ó–∞–ø—É—Å–∫ –∏ –±–æ—Ç–∞, –∏ health-—Å–µ—Ä–≤–µ—Ä–∞
async def main():
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    bot_task = asyncio.create_task(dp.start_polling(bot))
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä –¥–ª—è –∞–ø—Ç–∞–π–º–∞
    web_task = asyncio.create_task(start_web_app())
    # –ñ–¥—ë–º –æ–±–∞ —Ç–∞—Å–∫–∞
    await asyncio.gather(bot_task, web_task)

if __name__ == "__main__":
    asyncio.run(main())
    
